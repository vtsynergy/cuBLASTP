// smithWatermanTraceback.c
// Copyright (c) 2005, Michael Cameron
// Permission to use this code is freely granted under the BSD license agreement,
// provided that this statement is retained.
//
// Code to perform Smith-Waterman alignment and record traceback information

#include "blast.h"

int4* smithWatermanTraceback_matchRow = NULL;
int4* smithWatermanTraceback_insertQrow = NULL;
int4* smithWatermanTraceback_insertSrow = NULL;
int4 smithWatermanTraceback_rowSizes = 0;

// Prototypes
//struct trace smithWatermanTraceback_trace(struct dpResults dpResults, int4 queryLength);
void smithWatermanTraceback_print(int4* row, int4 subjectLength);
struct dpResults smithWatermanTraceback_dynamicProgramming(unsigned char* subject,
                                     struct PSSMatrix PSSMatrix, int4 subjectLength);
struct trace smithWatermanTraceback_trace(struct dpResults dpResults, int4 queryLength,
                                          struct PSSMatrix PSSMatrix, unsigned char* subject);

// Build a gapped extension with a trace and nominal score from the seed point of an ungapped
// extension using dynamic programming
struct gappedExtension* smithWatermanTraceback_build(struct PSSMatrix PSSMatrix, int4 subjectSize,
                        unsigned char* subject, struct coordinate start, struct coordinate end)
{
	struct trace trace;
	struct gappedExtension* gappedExtension;
    struct dpResults dpResults;

    // Only perform dynamic programming on region containing high-scoring alignment
	PSSMatrix = PSSMatrix_chop(PSSMatrix, start.queryOffset);
    PSSMatrix.length = end.queryOffset - start.queryOffset + 1;
    subject += start.subjectOffset;
    subjectSize = end.subjectOffset - start.subjectOffset + 1;

    // Perform dynamic programming
    dpResults = smithWatermanTraceback_dynamicProgramming(subject, PSSMatrix, subjectSize);

/*    printf("lengths=%d,%d\n", PSSMatrix.length, subjectSize);
	printf("Start=%d,%d\n", start.queryOffset, start.subjectOffset);
	printf("End=%d,%d\n", end.queryOffset, end.subjectOffset);
    printf("Best=%d,%d Score=%d dloc=%d\n", dpResults.best.queryOffset, dpResults.best.subjectOffset,
	                                        dpResults.bestScore);*/

	// Trace back and create the trace which specifies the alignment
	trace = smithWatermanTraceback_trace(dpResults, PSSMatrix.length, PSSMatrix, subject);
	trace.queryStart += start.queryOffset;
	trace.subjectStart += start.subjectOffset;

	// Create gapped extension
	gappedExtension = (struct gappedExtension*)global_malloc(sizeof(struct gappedExtension));
	gappedExtension->trace = trace;
	gappedExtension->next = NULL;

	gappedExtension->queryEnd = dpResults.best.queryOffset + start.queryOffset;
	gappedExtension->subjectEnd = dpResults.best.subjectOffset + start.subjectOffset;
	gappedExtension->nominalScore = dpResults.bestScore;

	return gappedExtension;
}

// Given the results of dynamic programming (a matrix of trace codes and a highest scoring position in
// the matrix), performs the simple operation of finding the path from the highest scoring point back
// to the 0 value cell that the alignment must begin at
struct trace smithWatermanTraceback_trace(struct dpResults dpResults, int4 queryLength,
                                          struct PSSMatrix PSSMatrix, unsigned char* subject)
{
	int4 queryPosition, subjectPosition;
	unsigned char** traceback;
	unsigned char traceCode;
	unsigned char state = 0;
	struct trace trace;
	unsigned char* traceCodes;
	uint4 traceCount = 0;

	traceback = dpResults.traceback;
	trace.queryStart = 0;
	trace.subjectStart = 0;

	// Start at the end of the alignment
	queryPosition = dpResults.best.queryOffset;
	subjectPosition = dpResults.best.subjectOffset;

	// Declare memory for tracecodes; for maximum possible number of codes that could
	// be generated by this trace
	traceCodes = (unsigned char*)global_malloc(sizeof(unsigned char) * (queryPosition + subjectPosition));

	while (queryPosition >= 0 && subjectPosition >= 0)
	{
		traceCode = traceback[queryPosition + 1][subjectPosition + 1];

//	if (dloc==39755)
//		printf("score=%d traceCode=%d state=%d\n", PSSMatrix.matrix[queryPosition][subject[subjectPosition]], traceCode, state);
		// If we got to current cell through a MATCH
		if (state == 0)
		{
			// We are only interested in lowest 2 bits of tracecode
			traceCode = traceCode << 6;
			traceCode = traceCode >> 6;

            if (traceCode == 3)
				break;

            // Move to cell before this one
			queryPosition--;
			subjectPosition--;

			// Tracecode determines if we matched or inserted here
			state = traceCode;
		}
		// If we got to current cell through an Ix
		else if (state == 1)
		{
			// Move to cell before this one
			subjectPosition--;

			// We are interest in bits 3rd and 4th from right
			traceCode = traceCode << 4;
			traceCode = traceCode >> 6;

			// Tracecode determines if we matched or inserted here
			state = traceCode;
		}
		// If we got to current cell through an Iy
		else if (state == 2)
		{
			// Move to cell before this one
			queryPosition--;

			// We are interest in bits 5th and 6th from right
			traceCode = traceCode << 2;
			traceCode = traceCode >> 6;

			// Tracecode determines if we matched or inserted here
			state = traceCode;
		}

		// Construct the trace
		traceCodes[traceCount] = state;
		traceCount++;
	}

	trace.queryStart = queryPosition + 1;
	trace.subjectStart = subjectPosition + 1;
	trace.traceCodes = traceCodes;
	trace.length = traceCount - 1;

	if (traceCount == 0)
	{
		trace.length = 0;
		free(traceCodes);
		trace.traceCodes = NULL;
	}

    // Reverse the tracecodes so they lead from start to end of alignment
	traceCodes = global_malloc(sizeof(unsigned char) * trace.length);
	traceCount = 0;
	while (traceCount < trace.length)
	{
		traceCodes[traceCount] = trace.traceCodes[trace.length - traceCount - 1];
		traceCount++;
	}

    // Use reversed codes and free the originals
	free(trace.traceCodes);
	trace.traceCodes = traceCodes;

	// Free memory used by traceback array
	queryPosition = 0;
	while (queryPosition < queryLength + 1)
	{
		free(traceback[queryPosition]);
		queryPosition++;
	}
	free(traceback);

	return trace;
}

// Perform dynamic programming
struct dpResults smithWatermanTraceback_dynamicProgramming(unsigned char* subject,
                                     struct PSSMatrix PSSMatrix, int4 subjectLength)
{
	int2 **queryPosition, **bestQueryPosition, **queryEnd;
	int2 *matrixColumn;
	unsigned char *subjectPosition, *bestSubjectPosition, *subjectEnd;
	unsigned char **traceback, **tracebackRow, *tracebackColumn;
	int4 bestScore = 0;
	int4 *matchRow, *insertQrow, *insertSrow;
	int4 oldMatch, match, previousOldMatch, previousOldInsertS, previousOldInsertQ;
	int4 previousMatch, previousInsertS;
	int4 queryDistance;
	struct dpResults dpResults;
	int4 queryLength;

	queryLength = PSSMatrix.length;
	subjectEnd = subject + subjectLength;
	queryEnd = PSSMatrix.matrix + queryLength;

	// Declare processing rows for storing match, insert-subject and insert-query values
	// If current malloced rows aren't big enough
	if (subjectLength >= smithWatermanTraceback_rowSizes)
	{
		// Free existing rows
		free(smithWatermanTraceback_matchRow);
		free(smithWatermanTraceback_insertQrow);
		free(smithWatermanTraceback_insertSrow);
		// Set size to double current needed length
		smithWatermanTraceback_rowSizes = subjectLength * 2;
		// Malloc new rows
		smithWatermanTraceback_matchRow = (int4*)global_malloc(sizeof(int4) * smithWatermanTraceback_rowSizes);
		smithWatermanTraceback_insertQrow = (int4*)global_malloc(sizeof(int4) * smithWatermanTraceback_rowSizes);
		smithWatermanTraceback_insertSrow = (int4*)global_malloc(sizeof(int4) * smithWatermanTraceback_rowSizes);
	}

	// Declare array to store traceback information, a row for each subject value
	traceback = (unsigned char**)global_malloc(sizeof(unsigned char*) * (queryLength + 1));

	queryDistance = 0;
	while (queryDistance < queryLength + 1)
	{
		// A column for each query value in the traceback array
		traceback[queryDistance]
			= (unsigned char*)global_malloc(sizeof(unsigned char) * (subjectLength + 1));

		queryDistance++;
	}

	bestSubjectPosition = subject;
	subjectPosition = subject - 1;
	bestQueryPosition = PSSMatrix.matrix;
	queryPosition = PSSMatrix.matrix - 1;

	// Initialize rows
	matchRow = smithWatermanTraceback_matchRow;
	insertQrow = smithWatermanTraceback_insertQrow;
	insertSrow = smithWatermanTraceback_insertSrow;

	// Initialize traceback pointers
	tracebackRow = traceback;
	tracebackColumn = *tracebackRow;

	// -----FIRST ROW-----
	// For each cell in the top row, scanning from left-to-right
	while (subjectPosition < subjectEnd)
	{
		// All values are zero
		*matchRow = *insertSrow = *insertQrow = 0;

		// Traceback is end-of-line
		*tracebackColumn = 3;

		matchRow++; insertQrow++; insertSrow++; tracebackColumn++; subjectPosition++;
	}

//	if (dloc==39755)
//	smithWatermanTraceback_print(smithWatermanTraceback_matchRow, subjectLength);

	tracebackRow++;
	queryPosition++;

	// -----REMAINING ROWS-----
	while (queryPosition < queryEnd)
	{
//		printf("%d/%d\n", queryPosition - PSSMatrix.matrix, queryEnd - PSSMatrix.matrix); fflush(stdout);

		subjectPosition = subject - 1;
		tracebackColumn = *tracebackRow;

		// Reset rows
		matchRow = smithWatermanTraceback_matchRow;
		insertQrow = smithWatermanTraceback_insertQrow;
		insertSrow = smithWatermanTraceback_insertSrow;

		// Using next column of the query matrix
		matrixColumn = (*queryPosition);

		// -----FAR LEFT CELL-----
		// Reset old values
		previousOldMatch = previousOldInsertQ = previousOldInsertS = 0;
		previousMatch = previousInsertS = 0;

		// All values are zero
		*matchRow = *insertSrow = *insertQrow = 0;

		// Traceback is end-of-line
		*tracebackColumn = 3;

		matchRow++; insertQrow++; insertSrow++; tracebackColumn++; subjectPosition++;

		// -----REMAINING CELLS-----
		while (subjectPosition < subjectEnd)
		{
			// Remember old M value (for cell below this one)
			oldMatch = *matchRow;

			// Calculate new M value
			if (previousOldMatch >= previousOldInsertQ)
			{
				if (previousOldMatch >= previousOldInsertS)
				{
					match = matrixColumn[*subjectPosition] + previousOldMatch;
					// M is derived from M
					*tracebackColumn = 0;
				}
				else
				{
					match = matrixColumn[*subjectPosition] + previousOldInsertS;
					// M is derived from Ix
					*tracebackColumn = 1;
				}
			}
			else
			{
				if (previousOldInsertQ >= previousOldInsertS)
				{
					match = matrixColumn[*subjectPosition] + previousOldInsertQ;
					// M is derived from Iy
					*tracebackColumn = 2;
				}
				else
				{
					match = matrixColumn[*subjectPosition] + previousOldInsertS;
					// M is derived from Ix
					*tracebackColumn = 1;
				}
			}
			
			*matchRow = match;

            // Record some old values
			previousOldMatch = oldMatch;
			previousOldInsertQ = *insertQrow;
			previousOldInsertS = *insertSrow;

			// Set new Iy value
//			printf("[%d/%d]", subjectPosition - subject, subjectEnd - subject); fflush(stdout);
			if (oldMatch - parameters_openGap >= *insertQrow - parameters_extendGap)
			{
				*insertQrow = oldMatch - parameters_openGap;
				// Iy is derived from M
				// No change to traceback
			}
			else
			{
				*insertQrow = *insertQrow - parameters_extendGap;
				// Iy is derived from Iy
				*tracebackColumn |= 32;
			}
			// Calculate new Ix
			if (previousMatch - parameters_openGap >= previousInsertS - parameters_extendGap)
			{
				*insertSrow = previousMatch - parameters_openGap;
				// Ix is derived from M
				// No change to traceback
			}
			else
			{
				*insertSrow = previousInsertS - parameters_extendGap;
				// Ix is derived from Ix
				*tracebackColumn |= 4;
			}

			// If this is the best-yet scoring cell
			if (match > bestScore)
			{
				// Update best start cell data
				bestScore = match;
				bestQueryPosition = queryPosition;
				bestSubjectPosition = subjectPosition;
			}

            // If match value is negative, convert to zero
			if (match <= 0)
			{
				*matchRow = 0;
				// End of line for traceback
				*tracebackColumn |= 3;
			}

			// Record match and insertS for this about-to-be-previous cell
			previousMatch = match;
			previousInsertS = *insertSrow;

			subjectPosition++; matchRow++; insertQrow++; insertSrow++; tracebackColumn++;
		}

		queryPosition++; tracebackRow++;

//	if (dloc==39755)
//		smithWatermanTraceback_print(smithWatermanTraceback_matchRow, subjectLength);
	}

	dpResults.best.queryOffset = bestQueryPosition - PSSMatrix.matrix;
	dpResults.best.subjectOffset = bestSubjectPosition - subject;
	dpResults.bestScore = bestScore;
	dpResults.traceback = traceback;

	return dpResults;
}


void smithWatermanTraceback_print(int4* row, int4 subjectLength)
{
	int4 count = 0;
	row++;

	while (count < subjectLength)
	{
		printf("%4d ", *row);
		row++;
		count++;
	}

	printf("\n");
}
